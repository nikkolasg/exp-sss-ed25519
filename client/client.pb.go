// Code generated by protoc-gen-go.
// source: client.proto
// DO NOT EDIT!

/*
Package client is a generated protocol buffer package.

It is generated from these files:
	client.proto

It has these top-level messages:
	ClientMessage
	ObjectToSign
	LocalFile
	RemoteFile
	Text
*/
package client

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ClientMessage struct {
}

func (m *ClientMessage) Reset()                    { *m = ClientMessage{} }
func (m *ClientMessage) String() string            { return proto.CompactTextString(m) }
func (*ClientMessage) ProtoMessage()               {}
func (*ClientMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// object to sign - abstract type, verified by its hash
type ObjectToSign struct {
	// Types that are valid to be assigned to Obj:
	//	*ObjectToSign_Remote
	//	*ObjectToSign_Local
	//	*ObjectToSign_Text
	Obj isObjectToSign_Obj `protobuf_oneof:"obj"`
}

func (m *ObjectToSign) Reset()                    { *m = ObjectToSign{} }
func (m *ObjectToSign) String() string            { return proto.CompactTextString(m) }
func (*ObjectToSign) ProtoMessage()               {}
func (*ObjectToSign) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isObjectToSign_Obj interface {
	isObjectToSign_Obj()
}

type ObjectToSign_Remote struct {
	Remote *RemoteFile `protobuf:"bytes,1,opt,name=remote,oneof"`
}
type ObjectToSign_Local struct {
	Local *LocalFile `protobuf:"bytes,2,opt,name=local,oneof"`
}
type ObjectToSign_Text struct {
	Text *Text `protobuf:"bytes,3,opt,name=text,oneof"`
}

func (*ObjectToSign_Remote) isObjectToSign_Obj() {}
func (*ObjectToSign_Local) isObjectToSign_Obj()  {}
func (*ObjectToSign_Text) isObjectToSign_Obj()   {}

func (m *ObjectToSign) GetObj() isObjectToSign_Obj {
	if m != nil {
		return m.Obj
	}
	return nil
}

func (m *ObjectToSign) GetRemote() *RemoteFile {
	if x, ok := m.GetObj().(*ObjectToSign_Remote); ok {
		return x.Remote
	}
	return nil
}

func (m *ObjectToSign) GetLocal() *LocalFile {
	if x, ok := m.GetObj().(*ObjectToSign_Local); ok {
		return x.Local
	}
	return nil
}

func (m *ObjectToSign) GetText() *Text {
	if x, ok := m.GetObj().(*ObjectToSign_Text); ok {
		return x.Text
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ObjectToSign) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ObjectToSign_OneofMarshaler, _ObjectToSign_OneofUnmarshaler, _ObjectToSign_OneofSizer, []interface{}{
		(*ObjectToSign_Remote)(nil),
		(*ObjectToSign_Local)(nil),
		(*ObjectToSign_Text)(nil),
	}
}

func _ObjectToSign_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ObjectToSign)
	// obj
	switch x := m.Obj.(type) {
	case *ObjectToSign_Remote:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Remote); err != nil {
			return err
		}
	case *ObjectToSign_Local:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Local); err != nil {
			return err
		}
	case *ObjectToSign_Text:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Text); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ObjectToSign.Obj has unexpected type %T", x)
	}
	return nil
}

func _ObjectToSign_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ObjectToSign)
	switch tag {
	case 1: // obj.remote
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RemoteFile)
		err := b.DecodeMessage(msg)
		m.Obj = &ObjectToSign_Remote{msg}
		return true, err
	case 2: // obj.local
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LocalFile)
		err := b.DecodeMessage(msg)
		m.Obj = &ObjectToSign_Local{msg}
		return true, err
	case 3: // obj.text
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Text)
		err := b.DecodeMessage(msg)
		m.Obj = &ObjectToSign_Text{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ObjectToSign_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ObjectToSign)
	// obj
	switch x := m.Obj.(type) {
	case *ObjectToSign_Remote:
		s := proto.Size(x.Remote)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObjectToSign_Local:
		s := proto.Size(x.Local)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ObjectToSign_Text:
		s := proto.Size(x.Text)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type LocalFile struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *LocalFile) Reset()                    { *m = LocalFile{} }
func (m *LocalFile) String() string            { return proto.CompactTextString(m) }
func (*LocalFile) ProtoMessage()               {}
func (*LocalFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *LocalFile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LocalFile) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// whatever file that can be grabbed from an URL.
// type of protocol depends on the application: http, ftp, etc
type RemoteFile struct {
	URL string `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
	// hash function to use
	HashFunc string `protobuf:"bytes,2,opt,name=hashFunc" json:"hashFunc,omitempty"`
	// hash of the content of the object
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *RemoteFile) Reset()                    { *m = RemoteFile{} }
func (m *RemoteFile) String() string            { return proto.CompactTextString(m) }
func (*RemoteFile) ProtoMessage()               {}
func (*RemoteFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RemoteFile) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *RemoteFile) GetHashFunc() string {
	if m != nil {
		return m.HashFunc
	}
	return ""
}

func (m *RemoteFile) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// ascii formatted string
type Text struct {
	Content string `protobuf:"bytes,1,opt,name=content" json:"content,omitempty"`
}

func (m *Text) Reset()                    { *m = Text{} }
func (m *Text) String() string            { return proto.CompactTextString(m) }
func (*Text) ProtoMessage()               {}
func (*Text) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Text) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func init() {
	proto.RegisterType((*ClientMessage)(nil), "ClientMessage")
	proto.RegisterType((*ObjectToSign)(nil), "ObjectToSign")
	proto.RegisterType((*LocalFile)(nil), "LocalFile")
	proto.RegisterType((*RemoteFile)(nil), "RemoteFile")
	proto.RegisterType((*Text)(nil), "Text")
}

func init() { proto.RegisterFile("client.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 240 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x4c, 0x90, 0x41, 0x4b, 0xc3, 0x40,
	0x14, 0x84, 0x5b, 0x93, 0x54, 0x33, 0x8d, 0x28, 0x7b, 0x0a, 0x7a, 0x29, 0x0b, 0x82, 0xa7, 0x1c,
	0xf4, 0xe4, 0x55, 0xa1, 0xf4, 0x50, 0x15, 0xd6, 0xfa, 0x03, 0x92, 0xe5, 0xd1, 0xa6, 0x6c, 0x77,
	0xa5, 0x79, 0x42, 0x2f, 0xfe, 0x77, 0xd9, 0x97, 0xb4, 0x7a, 0x9b, 0x2f, 0x6f, 0x26, 0x33, 0x2c,
	0x0a, 0xeb, 0x5a, 0xf2, 0x5c, 0x7d, 0xed, 0x03, 0x07, 0x7d, 0x85, 0xcb, 0x17, 0xe1, 0x57, 0xea,
	0xba, 0x7a, 0x4d, 0xfa, 0x07, 0xc5, 0x7b, 0xb3, 0x25, 0xcb, 0xab, 0xf0, 0xd1, 0xae, 0xbd, 0xba,
	0xc3, 0x64, 0x4f, 0xbb, 0xc0, 0x54, 0x8e, 0x67, 0xe3, 0xfb, 0xe9, 0xc3, 0xb4, 0x32, 0x82, 0xf3,
	0xd6, 0xd1, 0x62, 0x64, 0x86, 0xa3, 0xd2, 0xc8, 0x5c, 0xb0, 0xb5, 0x2b, 0xcf, 0xc4, 0x85, 0x6a,
	0x19, 0x69, 0x30, 0xf5, 0x27, 0x75, 0x8b, 0x94, 0xe9, 0xc0, 0x65, 0x22, 0x96, 0xac, 0x5a, 0xd1,
	0x81, 0x17, 0x23, 0x23, 0x1f, 0x9f, 0x33, 0x24, 0xa1, 0xd9, 0xea, 0x27, 0xe4, 0xa7, 0xa4, 0x52,
	0x48, 0x7d, 0xbd, 0xeb, 0x9b, 0x73, 0x23, 0x5a, 0x95, 0x38, 0xb7, 0xc1, 0x33, 0x79, 0x96, 0xaa,
	0xc2, 0x1c, 0x51, 0xbf, 0x01, 0x7f, 0xd3, 0xd4, 0x35, 0x92, 0x4f, 0xb3, 0x1c, 0xa2, 0x51, 0xaa,
	0x1b, 0x5c, 0x6c, 0xea, 0x6e, 0x33, 0xff, 0xf6, 0x56, 0xa2, 0xb9, 0x39, 0x71, 0x6c, 0x8a, 0x5a,
	0xa6, 0x15, 0x46, 0xb4, 0x9e, 0x21, 0x8d, 0x0b, 0xff, 0x37, 0xf6, 0x7f, 0x3b, 0x62, 0x33, 0x91,
	0x37, 0x7c, 0xfc, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x3e, 0xfd, 0xf8, 0xec, 0x53, 0x01, 0x00, 0x00,
}
